var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Grids","page":"API Reference","title":"Grids","text":"","category":"section"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#Operators","page":"API Reference","title":"Operators","text":"","category":"section"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Finite-Difference-Discretization","page":"Theory","title":"Finite Difference Discretization","text":"GridFunctions.jl is built around the concept of staggered grids, widely used in computational fluid dynamics and electromagnetics (e.g., Yee lattice) to preserve symmetries and conservation laws.","category":"section"},{"location":"theory/#Grid-Definitions","page":"Theory","title":"Grid Definitions","text":"We define two primary types of grid points in 1D:\n\nVertex (Collocated) Points:  The standard discretization of the domain x_min x_max.  $ xi = x{min} + (i-1)h, \\quad i=1, \\dots, N+1 $  where h = fracx_max-x_minN.\nCenter (Staggered) Points:  Points located at the midpoint between vertices.  $ x{i+1/2} = x{min} + (i-0.5)h, \\quad i=1, \\dots, N $\n\nIn GridFunctions, a generic N-dimensional grid is defined by a tuple of booleans (Shifts), indicating whether each dimension d is vertex-centered (false) or cell-centered (true).","category":"section"},{"location":"theory/#Discrete-Operators","page":"Theory","title":"Discrete Operators","text":"We implement mimetic operators that map fields between these grid types.","category":"section"},{"location":"theory/#Central-Difference-(Diff)","page":"Theory","title":"Central Difference (Diff)","text":"The central difference operator approximates the derivative partial_x with second-order accuracy. It maps properties from a Vertex grid to a Center grid (and vice versa).\n\n$\n\n(\\text{Diff}x u){i+1/2} = \\frac{u{i+1} - ui}{h} $\n\nIf u is defined on vertices, textDiff_x u naturally lives on cell centers.","category":"section"},{"location":"theory/#Averaging-(Avg)","page":"Theory","title":"Averaging (Avg)","text":"The averaging operator interpolates values between grid types.\n\n$\n\n(\\text{Avg}x u){i+1/2} = \\frac{u{i+1} + ui}{2} $","category":"section"},{"location":"theory/#Boundary-Conditions","page":"Theory","title":"Boundary Conditions","text":"Boundary conditions are handled via the grid topology:\n\nNonPeriodic: Bounds checking is enforced. Indices outside the valid range throw an error.\nPeriodic: Indices are wrapped modulo N.   $ u{N+1} \\equiv u1 $   This effectively models a domain on a torus.","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#1.-1D-Differentiation","page":"Examples","title":"1. 1D Differentiation","text":"Compute the derivative of f(x) = sin(x) on a periodic domain 0 2pi).\n\nusing GridFunctions\nusing StaticArrays\n\n# Create a periodic grid with 100 cells\ng = UniformGrid([0.0, 2π], 100, 1; topology=Periodic)\n\n# Define function u = sin(x)\nu = GridFunction(g, x -> sin(x[1]))\n\n# Compute derivative\n# Note: Diff(u, 1) returns a function on the Staggered grid\ndu_num = Diff(u, 1)\n\n# Analytical derivative on the staggered grid\n# We can evaluate cos(x) directly on the new grid for comparison\ndu_ana = GridFunction(du_num.grid, x -> cos(x[1]))\n\n# Check error\nerr = du_num - du_ana\nprintln(\"Max Error: \", maximum(abs.(err.values)))","category":"section"},{"location":"examples/#2.-2D-Laplacian","page":"Examples","title":"2. 2D Laplacian","text":"We can construct the discrete Laplacian nabla^2 = partial_x^2 + partial_y^2 by composing Diff operators. Note: textDiff_x maps Vertex to Center. Applying it again maps Center to Vertex.\n\n# 2D Periodic Grid 32x32\ng = UniformGrid2D([0, 2π], [0, 2π], 32, 32; topology=Periodic)\n\nu = GridFunction(g, x -> sin(x[1]) * cos(x[2]))\n\n# Laplacian u = d/dx(du/dx) + d/dy(du/dy)\n# First Derivatives (Staggered in X or Y)\ndx_u = Diff(u, 1)\ndy_u = Diff(u, 2)\n\n# Second Derivatives (Back to Vertex grid)\ndxx_u = Diff(dx_u, 1)\ndyy_u = Diff(dy_u, 2)\n\n# Laplacian\nlap_u = dxx_u + dyy_u\n\n# Analytical Laplacian: -(sin(x)cos(y) + sin(x)cos(y)) = -2u\n@assert isapprox(lap_u, -2.0 * u; atol=0.1)","category":"section"},{"location":"#GridFunctions.jl","page":"Home","title":"GridFunctions.jl","text":"<img src=\"GridFunctions_logo.svg\" align=\"right\" width=\"200\" alt=\"GridFunctions.jl Logo\">\n\nGridFunctions.jl is a high-performance Julia library for handling N-dimensional Cartesian grids, scalar fields (GridFunction), and discrete calculus operators. It provides a type-stable, zero-allocation framework for numerical analysis, simulation, and verifying discretization schemes.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"N-Dimensional Grids: Unified RectilinearGrid support for 1D, 2D, 3D, and N-D domains.\nFlexible Topology: Native support for Periodic and NonPeriodic boundary conditions.\nGeneralized Staggering: Arbitrary vertex/center staggering per dimension (e.g., Arakawa grids).\nDiscrete Calculus: Built-in, type-stable Diff (difference) and Avg (interpolation) operators that correctly handle staggering strings.\nExpression-like Syntax: Perform algebraic operations (+, -, *, sin, exp) directly on GridFunction objects.\nLazy Coordinates: Efficient, iterator-based coordinate generation to minimize memory usage.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"GridFunctions\")","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#1.-Creating-Grids","page":"Home","title":"1. Creating Grids","text":"GridFunctions supports generic N-D grids with intuitive constructors.\n\nusing GridFunctions\nusing StaticArrays\n\n# 1D Non-Periodic Grid (Vertex centered by default)\n# Domain [0, 10], 10 cells\ng1 = UniformGrid([0.0, 10.0], 10, 1) \n\n# 2D Periodic Grid\n# x: [0, 2π], 32 cells\n# y: [0, 2π], 32 cells\ng2 = UniformGrid2D([0, 2π], [0, 2π], 32, 32; topology=Periodic)\n\n# 2D Staggered Grid (Center-Center)\ng_staggered = UniformStaggeredGrid2D([0, 1], [0, 1], 10, 10)","category":"section"},{"location":"#2.-Defining-GridFunctions","page":"Home","title":"2. Defining GridFunctions","text":"You can define scalar fields using functions or existing arrays.\n\n# Define a Gaussian on a 2D grid\nf_xy = GridFunction(g2, x -> exp(-sin(x[1])^2 - sin(x[2])^2), Periodic)\n\n# Define from analytical function (automatically broadcasted)\nfunc = GridFunction(g1, x -> sin(x[1]))","category":"section"},{"location":"#3.-Indexing-and-Periodicity","page":"Home","title":"3. Indexing & Periodicity","text":"Accessing grids and functions is type-stable and handles boundary conditions automatically.\n\n# Get coordinate vector scalar\ncoord_1 = g1[1]        # SVector(0.0)\n\n# Periodic Wrapping\n# For a Periodic grid with 32 cells, index 33 wraps to 1.\nval_wrapped = g2[33, 1] # Equivalent to g2[1, 1] for Periodic\n\n# Bounds Checking (NonPeriodic)\n# g1[12] -> Throws BoundsError","category":"section"},{"location":"#4.-Discrete-Calculus-(Operators)","page":"Home","title":"4. Discrete Calculus (Operators)","text":"GridFunctions provides Diff and Avg operators that encompass the logic of staggered grids.\n\n# Define a field on a Vertex grid\nu = GridFunction(g1, x -> x[1]^2) # u = x^2\n\n# Compute Central Difference (maps Vertex -> Center)\n# du/dx approx 2x\ndu_dx = Diff(u, 1) \n\n# Check result topology\n# du_dx.grid is now a Center-staggered grid","category":"section"},{"location":"#5.-Algebraic-Operations","page":"Home","title":"5. Algebraic Operations","text":"GridFunctions behave like scalars in mathematical expressions.\n\nu = GridFunction(g2, x -> sin(x[1]))\nv = GridFunction(g2, x -> cos(x[1]))\n\n# All operations verify grid compatibility\nw = u^2 + v^2  # Result is approximately 1.0 everywhere\nz = exp(u) / 2.0","category":"section"},{"location":"#Operators-Overview","page":"Home","title":"Operators Overview","text":"Operator Description Staggering Effect\nDiff(u, dim) Central difference (u[i+1]-u[i])/h Flips dim (Vertex leftrightarrow Center)\nAvg(u, dim) Average 0.5*(u[i]+u[i+1]) Flips dim (Vertex leftrightarrow Center)","category":"section"}]
}
